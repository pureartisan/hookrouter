import React from 'react';
import isNode from './isNode';
import { setQueryParams } from './queryParams';
import { interceptRoute } from './interceptor';
let preparedRoutes = {};
let stack = {};
let componentId = 1;
let currentPath = isNode ? '' : location.pathname;
let basePath = '';
let basePathRegEx = null;
const pathUpdaters = [];
/**
 * Will define a base path that will be utilized in your routing and navigation.
 * To be called _before_ any routing or navigation happens.
 * @param {string} inBasepath
 */

export const setBasepath = inBasepath => {
  basePath = inBasepath;
  basePathRegEx = new RegExp('^' + basePath);
};
/**
 * Returns the currently used base path.
 * @returns {string}
 */

export const getBasepath = () => basePath;

const resolvePath = inPath => {
  if (isNode) {
    const url = require('url');

    return url.resolve(currentPath, inPath);
  }

  const current = new URL(currentPath, location.href);
  const resolved = new URL(inPath, current);
  return resolved.pathname;
};

export const ParentContext = React.createContext(null);
/**
 * Pass a route string to this function to receive a regular expression.
 * The transformation will be cached and if you pass the same route a second
 * time, the cached regex will be returned.
 * @param {string} inRoute
 * @returns {Array} [RegExp, propList]
 */

const prepareRoute = inRoute => {
  if (preparedRoutes[inRoute]) {
    return preparedRoutes[inRoute];
  }

  const preparedRoute = [new RegExp(`${inRoute.substr(0, 1) === '*' ? '' : '^'}${inRoute.replace(/:[a-zA-Z]+/g, '([^/]+)').replace(/\*/g, '')}${inRoute.substr(-1) === '*' ? '' : '$'}`)];
  const propList = inRoute.match(/:[a-zA-Z]+/g);
  preparedRoute.push(propList ? propList.map(paramName => paramName.substr(1)) : []);
  preparedRoutes[inRoute] = preparedRoute;
  return preparedRoute;
};
/**
 * Virtually navigates the browser to the given URL and re-processes all routers.
 * @param {string} url The URL to navigate to. Do not mix adding GET params here and using the `getParams` argument.
 * @param {boolean} [replace=false] Should the navigation be done with a history replace to prevent back navigation by the user
 * @param {object} [queryParams] Key/Value pairs to convert into get parameters to be appended to the URL.
 * @param {boolean} [replaceQueryParams=true] Should existing query parameters be carried over, or dropped (replaced)?
 */


export const navigate = (url, replace = false, queryParams = null, replaceQueryParams = true) => {
  url = interceptRoute(currentPath, resolvePath(url));

  if (!url || url === currentPath) {
    return;
  }

  currentPath = url;

  if (isNode) {
    setPath(url);
    processStack();
    updatePathHooks();
    return;
  }

  const finalURL = basePathRegEx ? url.match(basePathRegEx) ? url : basePath + url : url;
  window.history[`${replace ? 'replace' : 'push'}State`](null, null, finalURL);
  processStack();
  updatePathHooks();

  if (queryParams) {
    setQueryParams(queryParams, replaceQueryParams);
  }
};
let customPath = '/';
/**
 * Enables you to manually set the path from outside in a nodeJS environment, where window.history is not available.
 * @param {string} inPath
 */

export const setPath = inPath => {
  const url = require('url');

  customPath = url.resolve(customPath, inPath);
};
/**
 * Returns the current path of the router.
 * @returns {string}
 */

export const getPath = () => customPath;
/**
 * This hook returns the currently used URI.
 * Works in a browser context as well as for SSR.
 *
 * _Heads up:_ This will make your component render on every navigation unless you set this hook to passive!
 * @param {boolean} [active=true] Will update the component upon path changes. Set to false to only retrieve the path, once.
 * @param {boolean} [withBasepath=false] Should the base path be left at the beginning of the URI?
 * @returns {string}
 */

export const usePath = (active = true, withBasepath = false) => {
  const [, setUpdate] = React.useState(0);
  React.useEffect(() => {
    if (!active) {
      return;
    }

    pathUpdaters.push(setUpdate);
    return () => {
      const index = pathUpdaters.indexOf(setUpdate);

      if (index !== -1) {
        pathUpdaters.splice(index, 1);
      }
    };
  }, [setUpdate]);
  return withBasepath ? currentPath : currentPath.replace(basePathRegEx, '');
};
/**
 * Render all components that use path hooks.
 */

const updatePathHooks = () => {
  const now = Date.now();
  pathUpdaters.forEach(cb => cb(now));
};
/**
 * Called from within the router. This returns either the current windows url path
 * or a already reduced path, if a parent router has already matched with a finishing
 * wildcard before.
 * @param {string} [parentRouterId]
 * @returns {string}
 */


export const getWorkingPath = parentRouterId => {
  if (!parentRouterId) {
    return isNode ? customPath : window.location.pathname.replace(basePathRegEx, '') || '/';
  }

  const stackEntry = stack[parentRouterId];

  if (!stackEntry) {
    throw 'wth';
  }

  return stackEntry.reducedPath !== null ? stackEntry.reducedPath || '/' : window.location.pathname;
};

const processStack = () => Object.values(stack).forEach(process);
/**
 * This function takes two objects and compares if they have the same
 * keys and their keys have the same values assigned, so the objects are
 * basically the same.
 * @param {object} objA
 * @param {object} objB
 * @return {boolean}
 */


const objectsEqual = (objA, objB) => {
  const objAKeys = Object.keys(objA);
  const objBKeys = Object.keys(objB);

  const valueIsEqual = key => objB.hasOwnProperty(key) && objA[key] === objB[key];

  return objAKeys.length === objBKeys.length && objAKeys.every(valueIsEqual);
};

if (!isNode) {
  window.addEventListener('popstate', e => {
    const nextPath = interceptRoute(currentPath, location.pathname);

    if (!nextPath || nextPath === currentPath) {
      e.preventDefault();
      e.stopPropagation();
      history.pushState(null, null, currentPath);
      return;
    }

    currentPath = nextPath;

    if (nextPath !== location.pathname) {
      history.replaceState(null, null, nextPath);
    }

    processStack();
    updatePathHooks();
  });
}

const emptyFunc = () => null;
/**
 * This will calculate the match of a given router.
 * @param {object} stackObj
 * @param {boolean} [directCall] If its not a direct call, the process function might trigger a component render.
 */


const process = (stackObj, directCall) => {
  const {
    routerId,
    parentRouterId,
    routes,
    setUpdate,
    resultFunc,
    resultProps,
    reducedPath: previousReducedPath
  } = stackObj;
  const currentPath = getWorkingPath(parentRouterId);
  let route = null;
  let targetFunction = null;
  let targetProps = null;
  let reducedPath = null;
  let anyMatched = false;

  for (let i = 0; i < routes.length; i++) {
    [route, targetFunction] = routes[i];
    const [regex, groupNames] = preparedRoutes[route] ? preparedRoutes[route] : prepareRoute(route);
    const result = currentPath.match(regex);

    if (!result) {
      targetFunction = emptyFunc;
      continue;
    }

    if (groupNames.length) {
      targetProps = {};

      for (let j = 0; j < groupNames.length; j++) {
        targetProps[groupNames[j]] = result[j + 1];
      }
    }

    reducedPath = currentPath.replace(result[0], '');
    anyMatched = true;
    break;
  }

  if (!stack[routerId]) {
    return;
  }

  if (!anyMatched) {
    route = null;
    targetFunction = null;
    targetProps = null;
    reducedPath = null;
  }

  const funcsDiffer = resultFunc !== targetFunction;
  const pathDiffer = reducedPath !== previousReducedPath;
  let propsDiffer = true;

  if (!funcsDiffer) {
    if (!resultProps && !targetProps) {
      propsDiffer = false;
    } else {
      propsDiffer = !(resultProps && targetProps && objectsEqual(resultProps, targetProps) === true);
    }

    if (!propsDiffer) {
      if (!pathDiffer) {
        return;
      }
    }
  }

  const result = funcsDiffer || propsDiffer ? targetFunction ? targetFunction(targetProps) : null : stackObj.result;
  Object.assign(stack[routerId], {
    result,
    reducedPath,
    matchedRoute: route,
    passContext: route ? route.substr(-1) === '*' : false
  });

  if (!directCall && (funcsDiffer || propsDiffer || route === null)) {
    setUpdate(Date.now());
  }
};
/**
 * If a route returns a function, instead of a react element, we need to wrap this function
 * to eventually wrap a context object around its result.
 * @param RouteContext
 * @param originalResult
 * @returns {function(): *}
 */


const wrapperFunction = (RouteContext, originalResult) => function () {
  return React.createElement(RouteContext, null, originalResult.apply(originalResult, arguments));
};
/**
 * Pass an object to this function where the keys are routes and the values
 * are functions to be executed when a route matches. Whatever your function returns
 * will be returned from the hook as well into your react component. Ideally you would
 * return components to be rendered when certain routes match, but you are not limited
 * to that.
 * @param {object} routeObj {"/someRoute": () => <Example />}
 */


export const useRoutes = routeObj => {
  // Each router gets an internal id to look them up again.
  const [routerId] = React.useState(componentId);
  const setUpdate = React.useState(0)[1]; // Needed to create nested routers which use only a subset of the URL.

  const parentRouterId = React.useContext(ParentContext); // If we just took the last ID, increase it for the next hook.

  if (routerId === componentId) {
    componentId += 1;
  } // Removes the router from the stack after component unmount - it won't be processed anymore.


  React.useEffect(() => () => delete stack[routerId], [routerId]);
  let stackObj = stack[routerId];

  if (stackObj && stackObj.originalRouteObj !== routeObj) {
    stackObj = null;
  }

  if (!stackObj) {
    stackObj = {
      routerId,
      originalRouteObj: routeObj,
      routes: Object.entries(routeObj),
      setUpdate,
      parentRouterId,
      matchedRoute: null,
      reducedPath: null,
      passContext: false,
      result: null
    };
    stack[routerId] = stackObj;
    process(stackObj, true);
  }

  React.useDebugValue(stackObj.matchedRoute);

  if (!stackObj.matchedRoute) {
    return null;
  }

  let result = stackObj.result;

  if (!stackObj.passContext) {
    return result;
  } else {
    const RouteContext = ({
      children
    }) => React.createElement(ParentContext.Provider, {
      value: routerId
    }, children);

    if (typeof result === 'function') {
      return wrapperFunction(RouteContext, result);
    }

    return React.isValidElement(result) && result.type !== RouteContext ? React.createElement(RouteContext, null, result) : result;
  }
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9yb3V0ZXIuanMiXSwibmFtZXMiOlsiUmVhY3QiLCJpc05vZGUiLCJzZXRRdWVyeVBhcmFtcyIsImludGVyY2VwdFJvdXRlIiwicHJlcGFyZWRSb3V0ZXMiLCJzdGFjayIsImNvbXBvbmVudElkIiwiY3VycmVudFBhdGgiLCJsb2NhdGlvbiIsInBhdGhuYW1lIiwiYmFzZVBhdGgiLCJiYXNlUGF0aFJlZ0V4IiwicGF0aFVwZGF0ZXJzIiwic2V0QmFzZXBhdGgiLCJpbkJhc2VwYXRoIiwiUmVnRXhwIiwiZ2V0QmFzZXBhdGgiLCJyZXNvbHZlUGF0aCIsImluUGF0aCIsInVybCIsInJlcXVpcmUiLCJyZXNvbHZlIiwiY3VycmVudCIsIlVSTCIsImhyZWYiLCJyZXNvbHZlZCIsIlBhcmVudENvbnRleHQiLCJjcmVhdGVDb250ZXh0IiwicHJlcGFyZVJvdXRlIiwiaW5Sb3V0ZSIsInByZXBhcmVkUm91dGUiLCJzdWJzdHIiLCJyZXBsYWNlIiwicHJvcExpc3QiLCJtYXRjaCIsInB1c2giLCJtYXAiLCJwYXJhbU5hbWUiLCJuYXZpZ2F0ZSIsInF1ZXJ5UGFyYW1zIiwicmVwbGFjZVF1ZXJ5UGFyYW1zIiwic2V0UGF0aCIsInByb2Nlc3NTdGFjayIsInVwZGF0ZVBhdGhIb29rcyIsImZpbmFsVVJMIiwid2luZG93IiwiaGlzdG9yeSIsImN1c3RvbVBhdGgiLCJnZXRQYXRoIiwidXNlUGF0aCIsImFjdGl2ZSIsIndpdGhCYXNlcGF0aCIsInNldFVwZGF0ZSIsInVzZVN0YXRlIiwidXNlRWZmZWN0IiwiaW5kZXgiLCJpbmRleE9mIiwic3BsaWNlIiwibm93IiwiRGF0ZSIsImZvckVhY2giLCJjYiIsImdldFdvcmtpbmdQYXRoIiwicGFyZW50Um91dGVySWQiLCJzdGFja0VudHJ5IiwicmVkdWNlZFBhdGgiLCJPYmplY3QiLCJ2YWx1ZXMiLCJwcm9jZXNzIiwib2JqZWN0c0VxdWFsIiwib2JqQSIsIm9iakIiLCJvYmpBS2V5cyIsImtleXMiLCJvYmpCS2V5cyIsInZhbHVlSXNFcXVhbCIsImtleSIsImhhc093blByb3BlcnR5IiwibGVuZ3RoIiwiZXZlcnkiLCJhZGRFdmVudExpc3RlbmVyIiwiZSIsIm5leHRQYXRoIiwicHJldmVudERlZmF1bHQiLCJzdG9wUHJvcGFnYXRpb24iLCJwdXNoU3RhdGUiLCJyZXBsYWNlU3RhdGUiLCJlbXB0eUZ1bmMiLCJzdGFja09iaiIsImRpcmVjdENhbGwiLCJyb3V0ZXJJZCIsInJvdXRlcyIsInJlc3VsdEZ1bmMiLCJyZXN1bHRQcm9wcyIsInByZXZpb3VzUmVkdWNlZFBhdGgiLCJyb3V0ZSIsInRhcmdldEZ1bmN0aW9uIiwidGFyZ2V0UHJvcHMiLCJhbnlNYXRjaGVkIiwiaSIsInJlZ2V4IiwiZ3JvdXBOYW1lcyIsInJlc3VsdCIsImoiLCJmdW5jc0RpZmZlciIsInBhdGhEaWZmZXIiLCJwcm9wc0RpZmZlciIsImFzc2lnbiIsIm1hdGNoZWRSb3V0ZSIsInBhc3NDb250ZXh0Iiwid3JhcHBlckZ1bmN0aW9uIiwiUm91dGVDb250ZXh0Iiwib3JpZ2luYWxSZXN1bHQiLCJhcHBseSIsImFyZ3VtZW50cyIsInVzZVJvdXRlcyIsInJvdXRlT2JqIiwidXNlQ29udGV4dCIsIm9yaWdpbmFsUm91dGVPYmoiLCJlbnRyaWVzIiwidXNlRGVidWdWYWx1ZSIsImNoaWxkcmVuIiwiaXNWYWxpZEVsZW1lbnQiLCJ0eXBlIl0sIm1hcHBpbmdzIjoiQUFBQSxPQUFPQSxLQUFQLE1BQWtCLE9BQWxCO0FBQ0EsT0FBT0MsTUFBUCxNQUFtQixVQUFuQjtBQUNBLFNBQVFDLGNBQVIsUUFBNkIsZUFBN0I7QUFDQSxTQUFRQyxjQUFSLFFBQTZCLGVBQTdCO0FBRUEsSUFBSUMsY0FBYyxHQUFHLEVBQXJCO0FBQ0EsSUFBSUMsS0FBSyxHQUFHLEVBQVo7QUFDQSxJQUFJQyxXQUFXLEdBQUcsQ0FBbEI7QUFDQSxJQUFJQyxXQUFXLEdBQUdOLE1BQU0sR0FBRyxFQUFILEdBQVFPLFFBQVEsQ0FBQ0MsUUFBekM7QUFDQSxJQUFJQyxRQUFRLEdBQUcs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QVBIO0FBUVY0QyxNQUFBQSxXQUFXLEVBQUUsS0FSSDtBQVNWUCxNQUFBQSxNQUFNLEVBQUU7QUFURSxLQUFYO0FBWUFqRyxJQUFBQSxLQUFLLENBQUNxRixRQUFELENBQUwsR0FBa0JGLFFBQWxCO0FBRUFwQixJQUFBQSxPQUFPLENBQUNvQixRQUFELEVBQVcsSUFBWCxDQUFQO0FBQ0E7O0FBRUR4RixFQUFBQSxLQUFLLENBQUN3SCxhQUFOLENBQW9CaEMsUUFBUSxDQUFDb0IsWUFBN0I7O0FBRUEsTUFBSSxDQUFDcEIsUUFBUSxDQUFDb0IsWUFBZCxFQUE0QjtBQUMzQixXQUFPLElBQVA7QUFDQTs7QUFFRCxNQUFJTixNQUFNLEdBQUdkLFFBQVEsQ0FBQ2MsTUFBdEI7O0FBRUEsTUFBSSxDQUFDZCxRQUFRLENBQUNxQixXQUFkLEVBQTJCO0FBQzFCLFdBQU9QLE1BQVA7QUFDQSxHQUZELE1BRU87QUFDTixVQUFNUyxZQUFZLEdBQUcsQ0FBQztBQUFDVSxNQUFBQTtBQUFELEtBQUQsS0FBZ0Isb0JBQUMsYUFBRCxDQUFlLFFBQWY7QUFBd0IsTUFBQSxLQUFLLEVBQUUvQjtBQUEvQixPQUEwQytCLFFBQTFDLENBQXJDOztBQUVBLFFBQUksT0FBT25CLE1BQVAsS0FBa0IsVUFBdEIsRUFBa0M7QUFDakMsYUFBT1EsZUFBZSxDQUFDQyxZQUFELEVBQWVULE1BQWYsQ0FBdEI7QUFDQTs7QUFFRCxXQUFPdEcsS0FBSyxDQUFDMEgsY0FBTixDQUFxQnBCLE1BQXJCLEtBQWdDQSxNQUFNLENBQUNxQixJQUFQLEtBQWdCWixZQUFoRCxHQUNKLG9CQUFDLFlBQUQsUUFBZVQsTUFBZixDQURJLEdBRUpBLE1BRkg7QUFHQTtBQUNELENBNURNIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IGlzTm9kZSBmcm9tICcuL2lzTm9kZSc7XHJcbmltcG9ydCB7c2V0UXVlcnlQYXJhbXN9IGZyb20gJy4vcXVlcnlQYXJhbXMnO1xyXG5pbXBvcnQge2ludGVyY2VwdFJvdXRlfSBmcm9tICcuL2ludGVyY2VwdG9yJztcclxuXHJcbmxldCBwcmVwYXJlZFJvdXRlcyA9IHt9O1xyXG5sZXQgc3RhY2sgPSB7fTtcclxubGV0IGNvbXBvbmVudElkID0gMTtcclxubGV0IGN1cnJlbnRQYXRoID0gaXNOb2RlID8gJycgOiBsb2NhdGlvbi5wYXRobmFtZTtcclxubGV0IGJhc2VQYXRoID0gJyc7XHJcbmxldCBiYXNlUGF0aFJlZ0V4ID0gbnVsbDtcclxuY29uc3QgcGF0aFVwZGF0ZXJzID0gW107XHJcblxyXG4vKipcclxuICogV2lsbCBkZWZpbmUgYSBiYXNlIHBhdGggdGhhdCB3aWxsIGJlIHV0aWxpemVkIGluIHlvdXIgcm91dGluZyBhbmQgbmF2aWdhdGlvbi5cclxuICogVG8gYmUgY2FsbGVkIF9iZWZvcmVfIGFueSByb3V0aW5nIG9yIG5hdmlnYXRpb24gaGFwcGVucy5cclxuICogQHBhcmFtIHtzdHJpbmd9IGluQmFzZXBhdGhcclxuICovXHJcbmV4cG9ydCBjb25zdCBzZXRCYXNlcGF0aCA9IChpbkJhc2VwYXRoKSA9PiB7XHJcblx0YmFzZVBhdGggPSBpbkJhc2VwYXRoO1xyXG5cdGJhc2VQYXRoUmVnRXggPSBuZXcgUmVnRXhwKCdeJyArIGJhc2VQYXRoKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBjdXJyZW50bHkgdXNlZCBiYXNlIHBhdGguXHJcbiAqIEByZXR1cm5zIHtzdHJpbmd9XHJcbiAqL1xyXG5leHBvcnQgY29uc3QgZ2V0QmFzZXBhdGggPSAoKSA9PiBiYXNlUGF0aDtcclxuXHJcbmNvbnN0IHJlc29sdmVQYXRoID0gKGluUGF0aCkgPT4ge1xyXG5cdGlmIChpc05vZGUpIHtcclxuXHRcdGNvbnN0IHVybCA9IHJlcXVpcmUoJ3VybCcpO1xyXG5cdFx0cmV0dXJuIHVybC5yZXNvbHZlKGN1cnJlbnRQYXRoLCBpblBhdGgpO1xyXG5cdH1cclxuXHJcblx0Y29uc3QgY3VycmVudCA9IG5ldyBVUkwoY3VycmVudFBhdGgsIGxvY2F0aW9uLmhyZWYpO1xyXG5cdGNvbnN0IHJlc29sdmVkID0gbmV3IFVSTChpblBhdGgsIGN1cnJlbnQpO1xyXG5cdHJldHVybiByZXNvbHZlZC5wYXRobmFtZTtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBQYXJlbnRDb250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dChudWxsKTtcclxuXHJcbi8qKlxyXG4gKiBQYXNzIGEgcm91dGUgc3RyaW5nIHRvIHRoaXMgZnVuY3Rpb24gdG8gcmVjZWl2ZSBhIHJlZ3VsYXIgZXhwcmVzc2lvbi5cclxuICogVGhlIHRyYW5zZm9ybWF0aW9uIHdpbGwgYmUgY2FjaGVkIGFuZCBpZiB5b3UgcGFzcyB0aGUgc2FtZSByb3V0ZSBhIHNlY29uZFxyXG4gKiB0aW1lLCB0aGUgY2FjaGVkIHJlZ2V4IHdpbGwgYmUgcmV0dXJuZWQuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBpblJvdXRlXHJcbiAqIEByZXR1cm5zIHtBcnJheX0gW1JlZ0V4cCwgcHJvcExpc3RdXHJcbiAqL1xyXG5jb25zdCBwcmVwYXJlUm91dGUgPSAoaW5Sb3V0ZSkgPT4ge1xyXG5cdGlmIChwcmVwYXJlZFJvdXRlc1tpblJvdXRlXSkge1xyXG5cdFx0cmV0dXJuIHByZXBhcmVkUm91dGVzW2luUm91dGVdO1xyXG5cdH1cclxuXHJcblx0Y29uc3QgcHJlcGFyZWRSb3V0ZSA9IFtcclxuXHRcdG5ldyBSZWdFeHAoYCR7aW5Sb3V0ZS5zdWJzdHIoMCwgMSkgPT09ICcqJyA/ICcnIDogJ14nfSR7aW5Sb3V0ZS5yZXBsYWNlKC86W2EtekEtWl0rL2csICcoW14vXSspJykucmVwbGFjZSgvXFwqL2csICcnKX0ke2luUm91dGUuc3Vic3RyKC0xLCkgPT09ICcqJyA/ICcnIDogJyQnfWApXHJcblx0XTtcclxuXHJcblx0Y29uc3QgcHJvcExpc3QgPSBpblJvdXRlLm1hdGNoKC86W2EtekEtWl0rL2cpO1xyXG5cdHByZXBhcmVkUm91dGUucHVzaChcclxuXHRcdHByb3BMaXN0XHJcblx0XHRcdD8gcHJvcExpc3QubWFwKHBhcmFtTmFtZSA9PiBwYXJhbU5hbWUuc3Vic3RyKDEpKVxyXG5cdFx0XHQ6IFtdXHJcblx0KTtcclxuXHJcblx0cHJlcGFyZWRSb3V0ZXNbaW5Sb3V0ZV0gPSBwcmVwYXJlZFJvdXRlO1xyXG5cdHJldHVybiBwcmVwYXJlZFJvdXRlO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFZpcnR1YWxseSBuYXZpZ2F0ZXMgdGhlIGJyb3dzZXIgdG8gdGhlIGdpdmVuIFVSTCBhbmQgcmUtcHJvY2Vzc2VzIGFsbCByb3V0ZXJzLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsIFRoZSBVUkwgdG8gbmF2aWdhdGUgdG8uIERvIG5vdCBtaXggYWRkaW5nIEdFVCBwYXJhbXMgaGVyZSBhbmQgdXNpbmcgdGhlIGBnZXRQYXJhbXNgIGFyZ3VtZW50LlxyXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtyZXBsYWNlPWZhbHNlXSBTaG91bGQgdGhlIG5hdmlnYXRpb24gYmUgZG9uZSB3aXRoIGEgaGlzdG9yeSByZXBsYWNlIHRvIHByZXZlbnQgYmFjayBuYXZpZ2F0aW9uIGJ5IHRoZSB1c2VyXHJcbiAqIEBwYXJhbSB7b2JqZWN0fSBbcXVlcnlQYXJhbXNdIEtleS9WYWx1ZSBwYWlycyB0byBjb252ZXJ0IGludG8gZ2V0IHBhcmFtZXRlcnMgdG8gYmUgYXBwZW5kZWQgdG8gdGhlIFVSTC5cclxuICogQHBhcmFtIHtib29sZWFufSBbcmVwbGFjZVF1ZXJ5UGFyYW1zPXRydWVdIFNob3VsZCBleGlzdGluZyBxdWVyeSBwYXJhbWV0ZXJzIGJlIGNhcnJpZWQgb3Zlciwgb3IgZHJvcHBlZCAocmVwbGFjZWQpP1xyXG4gKi9cclxuZXhwb3J0IGNvbnN0IG5hdmlnYXRlID0gKHVybCwgcmVwbGFjZSA9IGZhbHNlLCBxdWVyeVBhcmFtcyA9IG51bGwsIHJlcGxhY2VRdWVyeVBhcmFtcyA9IHRydWUpID0+IHtcclxuXHR1cmwgPSBpbnRlcmNlcHRSb3V0ZShjdXJyZW50UGF0aCwgcmVzb2x2ZVBhdGgodXJsKSk7XHJcblxyXG5cdGlmICghdXJsIHx8IHVybCA9PT0gY3VycmVudFBhdGgpIHtcclxuXHRcdHJldHVybjtcclxuXHR9XHJcblxyXG5cdGN1cnJlbnRQYXRoID0gdXJsO1xyXG5cclxuXHRpZiAoaXNOb2RlKSB7XHJcblx0XHRzZXRQYXRoKHVybCk7XHJcblx0XHRwcm9jZXNzU3RhY2soKTtcclxuXHRcdHVwZGF0ZVBhdGhIb29rcygpO1xyXG5cdFx0cmV0dXJuO1xyXG5cdH1cclxuXHJcblx0Y29uc3QgZmluYWxVUkwgPSBiYXNlUGF0aFJlZ0V4XHJcblx0XHQ/IHVybC5tYXRjaChiYXNlUGF0aFJlZ0V4KVxyXG5cdFx0XHQ/IHVybFxyXG5cdFx0XHQ6IGJhc2VQYXRoICsgdXJsXHJcblx0XHQ6XHJcblx0XHR1cmw7XHJcblxyXG5cdHdpbmRvdy5oaXN0b3J5W2Ake3JlcGxhY2UgPyAncmVwbGFjZScgOiAncHVzaCd9U3RhdGVgXShudWxsLCBudWxsLCBmaW5hbFVSTCk7XHJcblx0cHJvY2Vzc1N0YWNrKCk7XHJcblx0dXBkYXRlUGF0aEhvb2tzKCk7XHJcblxyXG5cdGlmIChxdWVyeVBhcmFtcykge1xyXG5cdFx0c2V0UXVlcnlQYXJhbXMocXVlcnlQYXJhbXMsIHJlcGxhY2VRdWVyeVBhcmFtcyk7XHJcblx0fVxyXG59O1xyXG5cclxubGV0IGN1c3RvbVBhdGggPSAnLyc7XHJcbi8qKlxyXG4gKiBFbmFibGVzIHlvdSB0byBtYW51YWxseSBzZXQgdGhlIHBhdGggZnJvbSBvdXRzaWRlIGluIGEgbm9kZUpTIGVudmlyb25tZW50LCB3aGVyZSB3aW5kb3cuaGlzdG9yeSBpcyBub3QgYXZhaWxhYmxlLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gaW5QYXRoXHJcbiAqL1xyXG5leHBvcnQgY29uc3Qgc2V0UGF0aCA9IChpblBhdGgpID0+IHtcclxuXHRjb25zdCB1cmwgPSByZXF1aXJlKCd1cmwnKTtcclxuXHRjdXN0b21QYXRoID0gdXJsLnJlc29sdmUoY3VzdG9tUGF0aCwgaW5QYXRoKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBjdXJyZW50IHBhdGggb2YgdGhlIHJvdXRlci5cclxuICogQHJldHVybnMge3N0cmluZ31cclxuICovXHJcbmV4cG9ydCBjb25zdCBnZXRQYXRoID0gKCkgPT4gY3VzdG9tUGF0aDtcclxuXHJcbi8qKlxyXG4gKiBUaGlzIGhvb2sgcmV0dXJucyB0aGUgY3VycmVudGx5IHVzZWQgVVJJLlxyXG4gKiBXb3JrcyBpbiBhIGJyb3dzZXIgY29udGV4dCBhcyB3ZWxsIGFzIGZvciBTU1IuXHJcbiAqXHJcbiAqIF9IZWFkcyB1cDpfIFRoaXMgd2lsbCBtYWtlIHlvdXIgY29tcG9uZW50IHJlbmRlciBvbiBldmVyeSBuYXZpZ2F0aW9uIHVubGVzcyB5b3Ugc2V0IHRoaXMgaG9vayB0byBwYXNzaXZlIVxyXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFthY3RpdmU9dHJ1ZV0gV2lsbCB1cGRhdGUgdGhlIGNvbXBvbmVudCB1cG9uIHBhdGggY2hhbmdlcy4gU2V0IHRvIGZhbHNlIHRvIG9ubHkgcmV0cmlldmUgdGhlIHBhdGgsIG9uY2UuXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3dpdGhCYXNlcGF0aD1mYWxzZV0gU2hvdWxkIHRoZSBiYXNlIHBhdGggYmUgbGVmdCBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBVUkk/XHJcbiAqIEByZXR1cm5zIHtzdHJpbmd9XHJcbiAqL1xyXG5leHBvcnQgY29uc3QgdXNlUGF0aCA9IChhY3RpdmUgPSB0cnVlLCB3aXRoQmFzZXBhdGggPSBmYWxzZSkgPT4ge1xyXG5cdGNvbnN0IFssIHNldFVwZGF0ZV0gPSBSZWFjdC51c2VTdGF0ZSgwKTtcclxuXHJcblx0UmVhY3QudXNlRWZmZWN0KCgpID0+IHtcclxuXHRcdGlmICghYWN0aXZlKSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHRwYXRoVXBkYXRlcnMucHVzaChzZXRVcGRhdGUpO1xyXG5cdFx0cmV0dXJuICgpID0+IHtcclxuXHRcdFx0Y29uc3QgaW5kZXggPSBwYXRoVXBkYXRlcnMuaW5kZXhPZihzZXRVcGRhdGUpO1xyXG5cdFx0XHRpZiAoaW5kZXggIT09IC0xKSB7XHJcblx0XHRcdFx0cGF0aFVwZGF0ZXJzLnNwbGljZShpbmRleCwgMSk7XHJcblx0XHRcdH1cclxuXHRcdH07XHJcblx0fSwgW3NldFVwZGF0ZV0pO1xyXG5cclxuXHRyZXR1cm4gd2l0aEJhc2VwYXRoID8gY3VycmVudFBhdGggOiBjdXJyZW50UGF0aC5yZXBsYWNlKGJhc2VQYXRoUmVnRXgsICcnKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZW5kZXIgYWxsIGNvbXBvbmVudHMgdGhhdCB1c2UgcGF0aCBob29rcy5cclxuICovXHJcbmNvbnN0IHVwZGF0ZVBhdGhIb29rcyA9ICgpID0+IHtcclxuXHRjb25zdCBub3cgPSBEYXRlLm5vdygpO1xyXG5cdHBhdGhVcGRhdGVycy5mb3JFYWNoKGNiID0+IGNiKG5vdykpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENhbGxlZCBmcm9tIHdpdGhpbiB0aGUgcm91dGVyLiBUaGlzIHJldHVybnMgZWl0aGVyIHRoZSBjdXJyZW50IHdpbmRvd3MgdXJsIHBhdGhcclxuICogb3IgYSBhbHJlYWR5IHJlZHVjZWQgcGF0aCwgaWYgYSBwYXJlbnQgcm91dGVyIGhhcyBhbHJlYWR5IG1hdGNoZWQgd2l0aCBhIGZpbmlzaGluZ1xyXG4gKiB3aWxkY2FyZCBiZWZvcmUuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBbcGFyZW50Um91dGVySWRdXHJcbiAqIEByZXR1cm5zIHtzdHJpbmd9XHJcbiAqL1xyXG5leHBvcnQgY29uc3QgZ2V0V29ya2luZ1BhdGggPSAocGFyZW50Um91dGVySWQpID0+IHtcclxuXHRpZiAoIXBhcmVudFJvdXRlcklkKSB7XHJcblx0XHRyZXR1cm4gaXNOb2RlID8gY3VzdG9tUGF0aCA6IHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZS5yZXBsYWNlKGJhc2VQYXRoUmVnRXgsICcnKSB8fCAnLyc7XHJcblx0fVxyXG5cdGNvbnN0IHN0YWNrRW50cnkgPSBzdGFja1twYXJlbnRSb3V0ZXJJZF07XHJcblx0aWYgKCFzdGFja0VudHJ5KSB7XHJcblx0XHR0aHJvdyAnd3RoJztcclxuXHR9XHJcblxyXG5cdHJldHVybiBzdGFja0VudHJ5LnJlZHVjZWRQYXRoICE9PSBudWxsID8gc3RhY2tFbnRyeS5yZWR1Y2VkUGF0aCB8fCAnLycgOiB3aW5kb3cubG9jYXRpb24ucGF0aG5hbWU7XHJcbn07XHJcblxyXG5jb25zdCBwcm9jZXNzU3RhY2sgPSAoKSA9PiBPYmplY3QudmFsdWVzKHN0YWNrKS5mb3JFYWNoKHByb2Nlc3MpO1xyXG5cclxuLyoqXHJcbiAqIFRoaXMgZnVuY3Rpb24gdGFrZXMgdHdvIG9iamVjdHMgYW5kIGNvbXBhcmVzIGlmIHRoZXkgaGF2ZSB0aGUgc2FtZVxyXG4gKiBrZXlzIGFuZCB0aGVpciBrZXlzIGhhdmUgdGhlIHNhbWUgdmFsdWVzIGFzc2lnbmVkLCBzbyB0aGUgb2JqZWN0cyBhcmVcclxuICogYmFzaWNhbGx5IHRoZSBzYW1lLlxyXG4gKiBAcGFyYW0ge29iamVjdH0gb2JqQVxyXG4gKiBAcGFyYW0ge29iamVjdH0gb2JqQlxyXG4gKiBAcmV0dXJuIHtib29sZWFufVxyXG4gKi9cclxuY29uc3Qgb2JqZWN0c0VxdWFsID0gKG9iakEsIG9iakIpID0+IHtcclxuXHRjb25zdCBvYmpBS2V5cyA9IE9iamVjdC5rZXlzKG9iakEpO1xyXG5cdGNvbnN0IG9iakJLZXlzID0gT2JqZWN0LmtleXMob2JqQik7XHJcblxyXG5cdGNvbnN0IHZhbHVlSXNFcXVhbCA9IGtleSA9PiBvYmpCLmhhc093blByb3BlcnR5KGtleSkgJiYgb2JqQVtrZXldID09PSBvYmpCW2tleV07XHJcblxyXG5cdHJldHVybiAoXHJcblx0XHRvYmpBS2V5cy5sZW5ndGggPT09IG9iakJLZXlzLmxlbmd0aFxyXG5cdFx0JiYgb2JqQUtleXMuZXZlcnkodmFsdWVJc0VxdWFsKVxyXG5cdCk7XHJcbn07XHJcblxyXG5pZiAoIWlzTm9kZSkge1xyXG5cdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdwb3BzdGF0ZScsIChlKSA9PiB7XHJcblx0XHRjb25zdCBuZXh0UGF0aCA9IGludGVyY2VwdFJvdXRlKGN1cnJlbnRQYXRoLCBsb2NhdGlvbi5wYXRobmFtZSk7XHJcblxyXG5cdFx0aWYgKCFuZXh0UGF0aCB8fCBuZXh0UGF0aCA9PT0gY3VycmVudFBhdGgpIHtcclxuXHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cdFx0XHRlLnN0b3BQcm9wYWdhdGlvbigpO1xyXG5cdFx0XHRoaXN0b3J5LnB1c2hTdGF0ZShudWxsLCBudWxsLCBjdXJyZW50UGF0aCk7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHRjdXJyZW50UGF0aCA9IG5leHRQYXRoO1xyXG5cclxuXHRcdGlmIChuZXh0UGF0aCAhPT0gbG9jYXRpb24ucGF0aG5hbWUpIHtcclxuXHRcdFx0aGlzdG9yeS5yZXBsYWNlU3RhdGUobnVsbCwgbnVsbCwgbmV4dFBhdGgpO1xyXG5cdFx0fVxyXG5cdFx0cHJvY2Vzc1N0YWNrKCk7XHJcblx0XHR1cGRhdGVQYXRoSG9va3MoKTtcclxuXHR9KTtcclxufVxyXG5cclxuY29uc3QgZW1wdHlGdW5jID0gKCkgPT4gbnVsbDtcclxuXHJcbi8qKlxyXG4gKiBUaGlzIHdpbGwgY2FsY3VsYXRlIHRoZSBtYXRjaCBvZiBhIGdpdmVuIHJvdXRlci5cclxuICogQHBhcmFtIHtvYmplY3R9IHN0YWNrT2JqXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2RpcmVjdENhbGxdIElmIGl0cyBub3QgYSBkaXJlY3QgY2FsbCwgdGhlIHByb2Nlc3MgZnVuY3Rpb24gbWlnaHQgdHJpZ2dlciBhIGNvbXBvbmVudCByZW5kZXIuXHJcbiAqL1xyXG5jb25zdCBwcm9jZXNzID0gKHN0YWNrT2JqLCBkaXJlY3RDYWxsKSA9PiB7XHJcblx0Y29uc3Qge1xyXG5cdFx0cm91dGVySWQsXHJcblx0XHRwYXJlbnRSb3V0ZXJJZCxcclxuXHRcdHJvdXRlcyxcclxuXHRcdHNldFVwZGF0ZSxcclxuXHRcdHJlc3VsdEZ1bmMsXHJcblx0XHRyZXN1bHRQcm9wcyxcclxuXHRcdHJlZHVjZWRQYXRoOiBwcmV2aW91c1JlZHVjZWRQYXRoXHJcblx0fSA9IHN0YWNrT2JqO1xyXG5cclxuXHRjb25zdCBjdXJyZW50UGF0aCA9IGdldFdvcmtpbmdQYXRoKHBhcmVudFJvdXRlcklkKTtcclxuXHRsZXQgcm91dGUgPSBudWxsO1xyXG5cdGxldCB0YXJnZXRGdW5jdGlvbiA9IG51bGw7XHJcblx0bGV0IHRhcmdldFByb3BzID0gbnVsbDtcclxuXHRsZXQgcmVkdWNlZFBhdGggPSBudWxsO1xyXG5cdGxldCBhbnlNYXRjaGVkID0gZmFsc2U7XHJcblxyXG5cdGZvciAobGV0IGkgPSAwOyBpIDwgcm91dGVzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRbcm91dGUsIHRhcmdldEZ1bmN0aW9uXSA9IHJvdXRlc1tpXTtcclxuXHRcdGNvbnN0IFtyZWdleCwgZ3JvdXBOYW1lc10gPSBwcmVwYXJlZFJvdXRlc1tyb3V0ZV1cclxuXHRcdFx0PyBwcmVwYXJlZFJvdXRlc1tyb3V0ZV1cclxuXHRcdFx0OiBwcmVwYXJlUm91dGUocm91dGUpO1xyXG5cclxuXHRcdGNvbnN0IHJlc3VsdCA9IGN1cnJlbnRQYXRoLm1hdGNoKHJlZ2V4KTtcclxuXHRcdGlmICghcmVzdWx0KSB7XHJcblx0XHRcdHRhcmdldEZ1bmN0aW9uID0gZW1wdHlGdW5jO1xyXG5cdFx0XHRjb250aW51ZTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoZ3JvdXBOYW1lcy5sZW5ndGgpIHtcclxuXHRcdFx0dGFyZ2V0UHJvcHMgPSB7fTtcclxuXHRcdFx0Zm9yIChsZXQgaiA9IDA7IGogPCBncm91cE5hbWVzLmxlbmd0aDsgaisrKSB7XHJcblx0XHRcdFx0dGFyZ2V0UHJvcHNbZ3JvdXBOYW1lc1tqXV0gPSByZXN1bHRbaiArIDFdO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmVkdWNlZFBhdGggPSBjdXJyZW50UGF0aC5yZXBsYWNlKHJlc3VsdFswXSwgJycpO1xyXG5cdFx0YW55TWF0Y2hlZCA9IHRydWU7XHJcblx0XHRicmVhaztcclxuXHR9XHJcblxyXG5cdGlmICghc3RhY2tbcm91dGVySWRdKSB7XHJcblx0XHRyZXR1cm47XHJcblx0fVxyXG5cclxuXHRpZiAoIWFueU1hdGNoZWQpIHtcclxuXHRcdHJvdXRlID0gbnVsbDtcclxuXHRcdHRhcmdldEZ1bmN0aW9uID0gbnVsbDtcclxuXHRcdHRhcmdldFByb3BzID0gbnVsbDtcclxuXHRcdHJlZHVjZWRQYXRoID0gbnVsbDtcclxuXHR9XHJcblxyXG5cdGNvbnN0IGZ1bmNzRGlmZmVyID0gcmVzdWx0RnVuYyAhPT0gdGFyZ2V0RnVuY3Rpb247XHJcblx0Y29uc3QgcGF0aERpZmZlciA9IHJlZHVjZWRQYXRoICE9PSBwcmV2aW91c1JlZHVjZWRQYXRoO1xyXG5cdGxldCBwcm9wc0RpZmZlciA9IHRydWU7XHJcblxyXG5cdGlmICghZnVuY3NEaWZmZXIpIHtcclxuXHRcdGlmICghcmVzdWx0UHJvcHMgJiYgIXRhcmdldFByb3BzKSB7XHJcblx0XHRcdHByb3BzRGlmZmVyID0gZmFsc2U7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRwcm9wc0RpZmZlciA9ICEocmVzdWx0UHJvcHMgJiYgdGFyZ2V0UHJvcHMgJiYgb2JqZWN0c0VxdWFsKHJlc3VsdFByb3BzLCB0YXJnZXRQcm9wcykgPT09IHRydWUpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICghcHJvcHNEaWZmZXIpIHtcclxuXHRcdFx0aWYgKCFwYXRoRGlmZmVyKSB7XHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRjb25zdCByZXN1bHQgPSBmdW5jc0RpZmZlciB8fCBwcm9wc0RpZmZlclxyXG5cdFx0PyB0YXJnZXRGdW5jdGlvblxyXG5cdFx0XHQ/IHRhcmdldEZ1bmN0aW9uKHRhcmdldFByb3BzKVxyXG5cdFx0XHQ6IG51bGxcclxuXHRcdDogc3RhY2tPYmoucmVzdWx0O1xyXG5cclxuXHRPYmplY3QuYXNzaWduKHN0YWNrW3JvdXRlcklkXSwge1xyXG5cdFx0cmVzdWx0LFxyXG5cdFx0cmVkdWNlZFBhdGgsXHJcblx0XHRtYXRjaGVkUm91dGU6IHJvdXRlLFxyXG5cdFx0cGFzc0NvbnRleHQ6IHJvdXRlID8gcm91dGUuc3Vic3RyKC0xKSA9PT0gJyonIDogZmFsc2VcclxuXHR9KTtcclxuXHJcblx0aWYgKCFkaXJlY3RDYWxsICYmIChmdW5jc0RpZmZlciB8fCBwcm9wc0RpZmZlciB8fCByb3V0ZSA9PT0gbnVsbCkpIHtcclxuXHRcdHNldFVwZGF0ZShEYXRlLm5vdygpKTtcclxuXHR9XHJcbn07XHJcblxyXG4vKipcclxuICogSWYgYSByb3V0ZSByZXR1cm5zIGEgZnVuY3Rpb24sIGluc3RlYWQgb2YgYSByZWFjdCBlbGVtZW50LCB3ZSBuZWVkIHRvIHdyYXAgdGhpcyBmdW5jdGlvblxyXG4gKiB0byBldmVudHVhbGx5IHdyYXAgYSBjb250ZXh0IG9iamVjdCBhcm91bmQgaXRzIHJlc3VsdC5cclxuICogQHBhcmFtIFJvdXRlQ29udGV4dFxyXG4gKiBAcGFyYW0gb3JpZ2luYWxSZXN1bHRcclxuICogQHJldHVybnMge2Z1bmN0aW9uKCk6ICp9XHJcbiAqL1xyXG5jb25zdCB3cmFwcGVyRnVuY3Rpb24gPSAoUm91dGVDb250ZXh0LCBvcmlnaW5hbFJlc3VsdCkgPT4gZnVuY3Rpb24gKCl7XHJcblx0cmV0dXJuIChcclxuXHRcdDxSb3V0ZUNvbnRleHQ+e29yaWdpbmFsUmVzdWx0LmFwcGx5KG9yaWdpbmFsUmVzdWx0LCBhcmd1bWVudHMpfTwvUm91dGVDb250ZXh0PlxyXG5cdCk7XHJcbn07XHJcblxyXG4vKipcclxuICogUGFzcyBhbiBvYmplY3QgdG8gdGhpcyBmdW5jdGlvbiB3aGVyZSB0aGUga2V5cyBhcmUgcm91dGVzIGFuZCB0aGUgdmFsdWVzXHJcbiAqIGFyZSBmdW5jdGlvbnMgdG8gYmUgZXhlY3V0ZWQgd2hlbiBhIHJvdXRlIG1hdGNoZXMuIFdoYXRldmVyIHlvdXIgZnVuY3Rpb24gcmV0dXJuc1xyXG4gKiB3aWxsIGJlIHJldHVybmVkIGZyb20gdGhlIGhvb2sgYXMgd2VsbCBpbnRvIHlvdXIgcmVhY3QgY29tcG9uZW50LiBJZGVhbGx5IHlvdSB3b3VsZFxyXG4gKiByZXR1cm4gY29tcG9uZW50cyB0byBiZSByZW5kZXJlZCB3aGVuIGNlcnRhaW4gcm91dGVzIG1hdGNoLCBidXQgeW91IGFyZSBub3QgbGltaXRlZFxyXG4gKiB0byB0aGF0LlxyXG4gKiBAcGFyYW0ge29iamVjdH0gcm91dGVPYmoge1wiL3NvbWVSb3V0ZVwiOiAoKSA9PiA8RXhhbXBsZSAvPn1cclxuICovXHJcbmV4cG9ydCBjb25zdCB1c2VSb3V0ZXMgPSAocm91dGVPYmopID0+IHtcclxuXHQvLyBFYWNoIHJvdXRlciBnZXRzIGFuIGludGVybmFsIGlkIHRvIGxvb2sgdGhlbSB1cCBhZ2Fpbi5cclxuXHRjb25zdCBbcm91dGVySWRdID0gUmVhY3QudXNlU3RhdGUoY29tcG9uZW50SWQpO1xyXG5cdGNvbnN0IHNldFVwZGF0ZSA9IFJlYWN0LnVzZVN0YXRlKDApWzFdO1xyXG5cdC8vIE5lZWRlZCB0byBjcmVhdGUgbmVzdGVkIHJvdXRlcnMgd2hpY2ggdXNlIG9ubHkgYSBzdWJzZXQgb2YgdGhlIFVSTC5cclxuXHRjb25zdCBwYXJlbnRSb3V0ZXJJZCA9IFJlYWN0LnVzZUNvbnRleHQoUGFyZW50Q29udGV4dCk7XHJcblxyXG5cdC8vIElmIHdlIGp1c3QgdG9vayB0aGUgbGFzdCBJRCwgaW5jcmVhc2UgaXQgZm9yIHRoZSBuZXh0IGhvb2suXHJcblx0aWYgKHJvdXRlcklkID09PSBjb21wb25lbnRJZCkge1xyXG5cdFx0Y29tcG9uZW50SWQgKz0gMTtcclxuXHR9XHJcblxyXG5cdC8vIFJlbW92ZXMgdGhlIHJvdXRlciBmcm9tIHRoZSBzdGFjayBhZnRlciBjb21wb25lbnQgdW5tb3VudCAtIGl0IHdvbid0IGJlIHByb2Nlc3NlZCBhbnltb3JlLlxyXG5cdFJlYWN0LnVzZUVmZmVjdCgoKSA9PiAoKSA9PiBkZWxldGUgc3RhY2tbcm91dGVySWRdLCBbcm91dGVySWRdKTtcclxuXHJcblx0bGV0IHN0YWNrT2JqID0gc3RhY2tbcm91dGVySWRdO1xyXG5cclxuXHRpZiAoc3RhY2tPYmogJiYgc3RhY2tPYmoub3JpZ2luYWxSb3V0ZU9iaiAhPT0gcm91dGVPYmopIHtcclxuXHRcdHN0YWNrT2JqID0gbnVsbDtcclxuXHR9XHJcblxyXG5cdGlmICghc3RhY2tPYmopIHtcclxuXHRcdHN0YWNrT2JqID0ge1xyXG5cdFx0XHRyb3V0ZXJJZCxcclxuXHRcdFx0b3JpZ2luYWxSb3V0ZU9iajogcm91dGVPYmosXHJcblx0XHRcdHJvdXRlczogT2JqZWN0LmVudHJpZXMocm91dGVPYmopLFxyXG5cdFx0XHRzZXRVcGRhdGUsXHJcblx0XHRcdHBhcmVudFJvdXRlcklkLFxyXG5cdFx0XHRtYXRjaGVkUm91dGU6IG51bGwsXHJcblx0XHRcdHJlZHVjZWRQYXRoOiBudWxsLFxyXG5cdFx0XHRwYXNzQ29udGV4dDogZmFsc2UsXHJcblx0XHRcdHJlc3VsdDogbnVsbFxyXG5cdFx0fTtcclxuXHJcblx0XHRzdGFja1tyb3V0ZXJJZF0gPSBzdGFja09iajtcclxuXHJcblx0XHRwcm9jZXNzKHN0YWNrT2JqLCB0cnVlKTtcclxuXHR9XHJcblxyXG5cdFJlYWN0LnVzZURlYnVnVmFsdWUoc3RhY2tPYmoubWF0Y2hlZFJvdXRlKTtcclxuXHJcblx0aWYgKCFzdGFja09iai5tYXRjaGVkUm91dGUpIHtcclxuXHRcdHJldHVybiBudWxsO1xyXG5cdH1cclxuXHJcblx0bGV0IHJlc3VsdCA9IHN0YWNrT2JqLnJlc3VsdDtcclxuXHJcblx0aWYgKCFzdGFja09iai5wYXNzQ29udGV4dCkge1xyXG5cdFx0cmV0dXJuIHJlc3VsdDtcclxuXHR9IGVsc2Uge1xyXG5cdFx0Y29uc3QgUm91dGVDb250ZXh0ID0gKHtjaGlsZHJlbn0pID0+IDxQYXJlbnRDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXtyb3V0ZXJJZH0+e2NoaWxkcmVufTwvUGFyZW50Q29udGV4dC5Qcm92aWRlcj47XHJcblxyXG5cdFx0aWYgKHR5cGVvZiByZXN1bHQgPT09ICdmdW5jdGlvbicpIHtcclxuXHRcdFx0cmV0dXJuIHdyYXBwZXJGdW5jdGlvbihSb3V0ZUNvbnRleHQsIHJlc3VsdCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIFJlYWN0LmlzVmFsaWRFbGVtZW50KHJlc3VsdCkgJiYgcmVzdWx0LnR5cGUgIT09IFJvdXRlQ29udGV4dFxyXG5cdFx0XHQ/IDxSb3V0ZUNvbnRleHQ+e3Jlc3VsdH08L1JvdXRlQ29udGV4dD5cclxuXHRcdFx0OiByZXN1bHQ7XHJcblx0fVxyXG59O1xyXG4iXX0=